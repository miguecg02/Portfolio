<!doctype html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TMChess3D - Ajedrez 3D</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ôüÔ∏è</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a3d7c 0%, #2a5ca0 50%, #3fb8af 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            text-align: center;
        }
        .container { width: 100%; max-width: 1200px; display: flex; flex-direction: column; align-items: center; gap: 25px; }
        .button-group {
            display: flex;
            gap: 15px;
            align-self: flex-start;
            flex-wrap: wrap;
        }
        .back-button, .github-button {
            display: inline-flex;
            align-items: center;
            padding: 12px 24px;
            color: white;
            text-decoration: none;
            border-radius: 12px;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        .back-button {
            background-color: rgba(255,255,255,0.2);
        }
        .back-button:hover {
            background-color: white;
            color: #1a3d7c;
            transform: translateY(-2px);
        }
        .github-button {
            background-color: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.3);
        }
        .github-button:hover {
            background-color: #333;
            transform: translateY(-2px);
        }
        .header { margin-bottom: 10px; }
        h1 { font-size: 2.5rem; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .subtitle { font-size: 1.2rem; opacity: 0.9; margin-bottom: 30px; }
        .game-container { width: 100%; height: 70vh; border-radius: 12px; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.4); margin: 20px 0; position: relative; }
        #chessCanvas { width: 100%; height: 100%; display: block; }
        .instructions { background: rgba(255,255,255,0.1); padding: 25px; border-radius: 12px; width: 100%; text-align: left; margin: 20px 0; }
        .instructions h3 { margin-bottom: 15px; font-size: 1.4rem; text-align: center; }
        .instructions ul { list-style-type: none; }
        .instructions li { margin-bottom: 10px; padding-left: 25px; position: relative; }
        .instructions li:before { content: "‚Ä¢"; color: #3fb8af; font-weight: bold; position: absolute; left: 0; }
        .loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; background: rgba(0,0,0,0.8); z-index: 10; }
        .spinner { width: 50px; height: 50px; border: 5px solid rgba(255,255,255,0.3); border-radius: 50%; border-top: 5px solid #3fb8af; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }
        .error-message { color: #ff6b6b; text-align:center; padding:20px; display:none; }
        .retry-button { margin-top: 15px; padding: 10px 20px; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; }
        .retry-button:hover { background: rgba(255,255,255,0.3); }
        .debug-panel { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; z-index: 1000; font-size: 12px; border-radius: 5px; max-width: 300px; display: none; }
        .debug-toggle { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; border: none; border-radius: 5px; padding: 5px 10px; cursor: pointer; z-index: 1001; }
        .progress-bar { width: 80%; max-width: 300px; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; margin-top: 15px; overflow: hidden; }
        .progress { height: 100%; background: #3fb8af; width: 0%; transition: width 0.3s ease; }
        .server-info { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-top: 15px; text-align: left; max-width: 500px; }
        .server-info h4 { margin-bottom: 10px; text-align:center; }
        .code { font-family: monospace; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; overflow-x: auto; }
        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .subtitle { font-size: 1rem; }
            .game-container { height: 50vh; }
            .debug-panel { top: 50px; right: 10px; max-width: 200px; }
            .button-group { flex-direction: column; align-items: flex-start; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Grupo de botones agregado -->
        <div class="button-group">
            <a href="index.html" class="back-button">‚Üê Volver al Portfolio</a>
            <a href="https://github.com/Toni-Marti/TMChess3D" class="github-button" target="_blank">‚≠ê Ver en GitHub</a>
        </div>

        <div class="header">
            <h1>TMChess3D - Ajedrez en 3D</h1>
            <p class="subtitle">Una experiencia de ajedrez inmersiva con gr√°ficos 3D</p>
        </div>

        <div class="game-container">
            <div id="loading" class="loading">
                <div class="spinner"></div>
                <div id="loading-text">Cargando ajedrez 3D...</div>
                <div id="loading-details" style="margin-top: 10px; font-size: 12px;"></div>
                <div class="progress-bar">
                    <div id="progress-bar-inner" class="progress"></div>
                </div>
            </div>
            <canvas id="chessCanvas"></canvas>
            <div id="error" class="error-message">
                <p>No se pudo cargar el juego. Esto puede deberse a:</p>
                <ul>
                    <li>Tu navegador no soporta WebGL</li>
                    <li>Problemas al cargar los recursos del juego</li>
                    <li>El servidor local no est√° funcionando correctamente</li>
                </ul>
                <div class="server-info">
                    <h4>Para solucionarlo:</h4>
                    <ol>
                        <li>Abre una terminal/consola en la carpeta del proyecto</li>
                        <li>Ejecuta el siguiente comando:</li>
                        <div class="code">python server-launcher.py</div>
                        <li>Accede a la aplicaci√≥n mediante la URL que se muestra (normalmente http://localhost:8000/chess.html)</li>
                    </ol>
                </div>
                <div id="error-details" style="margin-top: 15px; text-align: left; font-size: 14px;"></div>
                <button class="retry-button" onclick="retryLoad()">Reintentar</button>
            </div>
        </div>

        <div class="instructions">
            <h3>Instrucciones:</h3>
            <ul>
                <li>Haz clic en una pieza para seleccionarla</li>
                <li>La torre y el pe√≥n tienen animaciones al capturar</li>
                <li>Las casillas verdes indican movimientos v√°lidos</li>
                <li>Usa la rueda del mouse para acercar/alejar</li>
                <li>Haz clic y arrastra para rotar la c√°mara</li>
                <li>Presiona 'C' para cambiar la vista de la c√°mara</li>
                <li>Presiona 'S' para reiniciar el juego</li>
                <li>Disfruta de la experiencia 3D inmersiva</li>
            </ul>
        </div>
    </div>

    <button class="debug-toggle" onclick="toggleDebug()">Debug</button>
    <div class="debug-panel" id="debug-panel">
        <h4>Estado de carga:</h4>
        <div id="debug-info"></div>
    </div>

    <script type="module">
        // --- Estado de carga mejorado ---
        const loadStatus = {
            three: false,
            tween: false,
            chessGame: false,
            board: false,
            materialSets: false,
            utils: false,
            geometry: false,
            abstractPiece: false,
            pieces: false,
            scene: false,
            optionalLibs: false // Nuevo estado para bibliotecas opcionales
        };

        let totalModules = Object.keys(loadStatus).length;
        let loadedModules = 0;

        function updateProgress() {
            loadedModules++;
            const progress = (loadedModules / totalModules) * 100;
            const el = document.getElementById('progress-bar-inner');
            if (el) el.style.width = `${progress}%`;
            updateDebugInfo();
        }

        function updateLoadingText(text) {
            const loadingDetails = document.getElementById('loading-details');
            const loadingText = document.getElementById('loading-text');
            if (loadingDetails) loadingDetails.textContent = text;
            if (loadingText) loadingText.textContent = text;
            console.log('[Loading] ' + text);
        }

        function updateDebugInfo() {
            const debugInfo = document.getElementById('debug-panel');
            if (!debugInfo) return;

            const info = document.getElementById('debug-info');
            info.innerHTML = Object.entries(loadStatus)
                .map(([key, value]) => `<div>${key}: ${value ? '‚úÖ' : '‚ùå'}</div>`)
                .join('');
        }

        // --- Funci√≥n de carga de m√≥dulos ES (con 'export') robusta ---
        async function loadModule(modulePath, moduleName, maxRetries = 2) {
            updateLoadingText(`Cargando ${moduleName} (M√≥dulo)...`);

            const correctedPath = './TMChess3D/' + modulePath;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    console.log(`üì¶ Intentando cargar ${moduleName} desde: ${correctedPath} (intento ${attempt})`);
                    const module = await import(correctedPath);
                    console.log(`‚úÖ ${moduleName} cargado exitosamente`);
                    return module;
                } catch (error) {
                    console.error(`‚ùå Error cargando ${moduleName} (intento ${attempt}):`, error);

                    if (attempt < maxRetries) {
                        updateLoadingText(`Reintentando ${moduleName}... (${attempt}/${maxRetries})`);
                        await new Promise(res => setTimeout(res, 1000 * attempt));
                    } else {
                        throw new Error(`No se pudo cargar ${moduleName} despu√©s de ${maxRetries} intentos: ${error.message}`);
                    }
                }
            }
        }

        // --- FUNCI√ìN DE CARGA DE SCRIPT TRADICIONAL ROBUSTA (con Timeout) ---
        async function loadScript(scriptPath, scriptName, timeoutMs = 5000) {
            updateLoadingText(`Cargando ${scriptName} (Script)...`);
            const correctedPath = './TMChess3D/' + scriptPath;

            console.log(`üìú Intentando cargar ${scriptName} desde: ${correctedPath}`);

            return new Promise((resolve) => {
                const scriptEl = document.createElement('script');
                scriptEl.src = correctedPath;
                scriptEl.async = false; // Importante para la secuencia de ejecuci√≥n

                const timer = setTimeout(() => {
                    console.warn(`‚ö†Ô∏è Timeout (${timeoutMs}ms) al cargar ${scriptName}.`);
                    scriptEl.onload = scriptEl.onerror = null;
                    // Retiramos el elemento para evitar que se ejecute tarde
                    if(document.head.contains(scriptEl)) {
                        document.head.removeChild(scriptEl);
                    }
                    resolve(false);
                }, timeoutMs);

                scriptEl.onload = () => {
                    clearTimeout(timer);
                    console.log(`‚úÖ ${scriptName} cargado exitosamente.`);
                    resolve(true);
                };

                scriptEl.onerror = (e) => {
                    clearTimeout(timer);
                    console.error(`‚ùå Error al cargar ${scriptName} (recurso no encontrado/error de red).`, e);
                    // Retiramos el elemento fallido
                    if(document.head.contains(scriptEl)) {
                        document.head.removeChild(scriptEl);
                    }
                    resolve(false);
                };

                // Inyectamos el script para iniciar la descarga y ejecuci√≥n
                document.head.appendChild(scriptEl);
            });
        }


        // --- CARGAR DEPENDENCIAS PRINCIPALES MEJORADO (M√≥dulos ES) ---
        async function loadCoreDependencies() {
            try {
                updateLoadingText("Inicializando motor 3D...");

                // THREE.js (M√≥dulo ES)
                const threeModule = await loadModule('libs/three.module.js', 'THREE', 3);
                window.THREE = threeModule.default || threeModule;
                loadStatus.three = true;
                updateProgress();

                // TWEEN.js (M√≥dulo ES)
                const tweenModule = await loadModule('libs/tween.module.js', 'TWEEN', 3);
                window.TWEEN = tweenModule.default || tweenModule;
                loadStatus.tween = true;
                updateProgress();

                // Chess Game (M√≥dulo ES)
                const chessModule = await loadModule('our_libs/chess/game_handler.js', 'ChessGame');
                window.ChessGame = chessModule.ChessGame || chessModule.default || chessModule;
                loadStatus.chessGame = true;
                updateProgress();

                // Board (M√≥dulo ES)
                const boardModule = await loadModule('Objects/Board.js', 'Board');
                window.Board = boardModule.Board || boardModule.default || boardModule;
                loadStatus.board = true;
                updateProgress();

                // Material Sets (M√≥dulo ES)
                const materialModule = await loadModule('Objects/Pieces/Materials/MaterialSetLibrary.js', 'MaterialSets');
                window.PiceMaterialSets = materialModule.default || materialModule;
                loadStatus.materialSets = true;
                updateProgress();

                console.log("‚úÖ Todas las dependencias principales cargadas");

            } catch (error) {
                throw new Error(`Error en dependencias principales: ${error.message}`);
            }
        }

        // --- CARGAR SISTEMA DE GEOMETR√çA (M√≥dulos ES) ---
        async function loadGeometrySystem() {
            try {
                updateLoadingText("Configurando sistema de geometr√≠a...");

                const deps = [
                    ['our_libs/utility/utils.js', 'Utils'],
                    ['our_libs/geometry/point.js', 'Point'],
                    ['our_libs/geometry/line.js', 'Line'],
                    ['our_libs/geometry/shapes.js', 'Shapes'],
                    ['our_libs/three_helpers/shapes.js', 'ThreeShapes']
                ];

                for (const [path, name] of deps) {
                    await loadModule(path, name);
                }

                loadStatus.utils = true;
                loadStatus.geometry = true;
                updateProgress();

            } catch (error) {
                console.warn("‚ö†Ô∏è Algunas dependencias de geometr√≠a no est√°n disponibles, continuando...");
            }
        }

        // --- Funci√≥n para crear piezas de respaldo (sin cambios) ---
        function createFallbackPiece(pieceName) {
            return class FallbackPiece extends THREE.Object3D {
                constructor(material_set, row, col, color) {
                    super();

                    // Posicionar en el tablero (centrado en 0,0)
                    this.position.set(
                        col - 3.5,
                        0,
                        row - 3.5
                    );

                    this.material_set = material_set;
                    this.row = row;
                    this.col = col;
                    this.color = color;

                    // Geometr√≠a b√°sica seg√∫n el tipo de pieza
                    let geometry;
                    let height = 1.0;

                    switch(pieceName.toLowerCase()) {
                        case 'pawn':
                            geometry = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 8);
                            height = 1.2;
                            break;
                        case 'knight':
                            geometry = new THREE.ConeGeometry(0.4, 1.4, 6);
                            height = 1.4;
                            break;
                        case 'bishop':
                            geometry = new THREE.ConeGeometry(0.35, 1.7, 8);
                            height = 1.7;
                            break;
                        case 'rook':
                            geometry = new THREE.BoxGeometry(0.6, 1.3, 0.6);
                            height = 1.3;
                            break;
                        case 'queen':
                            geometry = new THREE.ConeGeometry(0.5, 1.8, 8);
                            height = 1.8;
                            break;
                        case 'king':
                            geometry = new THREE.CylinderGeometry(0.3, 0.5, 2.0, 8);
                            height = 2.0;
                            // A√±adir cruz simple para el rey
                            const crossGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1);
                            const cross = new THREE.Mesh(crossGeometry, material_set.metal || new THREE.MeshBasicMaterial({color: 0xffff00}));
                            cross.position.y = height/2 + 0.2;
                            this.add(cross);
                            break;
                        default:
                            geometry = new THREE.BoxGeometry(0.5, 1.0, 0.5);
                    }

                    const mesh = new THREE.Mesh(geometry, material_set.piece_body);
                    mesh.position.y = height/2;
                    this.add(mesh);

                    // Base para todas las piezas
                    const baseGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 16);
                    const base = new THREE.Mesh(baseGeometry, material_set.piece_body);
                    base.position.y = 0.1;
                    this.add(base);
                }

                async move(to, duration = 1000) {
                    return new Promise(resolve => {
                        new TWEEN.Tween(this.position)
                            .to({
                                x: to.x !== undefined ? to.x : this.position.x,
                                y: to.y !== undefined ? to.y : this.position.y,
                                z: to.z !== undefined ? to.z : this.position.z
                            }, duration)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .onComplete(resolve)
                            .start();
                    });
                }

                update() {
                    // M√©todo vac√≠o para compatibilidad
                }
            };
        }

        // --- CARGAR PIEZAS MEJORADO (M√≥dulos ES) ---
        async function loadPieces() {
            try {
                updateLoadingText("Preparando piezas de ajedrez...");

                // Cargar base y AbstractPiece primero
                await loadModule('Objects/Pieces/base.js', 'Base');
                const abstractModule = await loadModule('Objects/Pieces/AbstractPiece.js', 'AbstractPiece');
                window.AbstractPiece = abstractModule.AbstractPiece || abstractModule.default || abstractModule;
                loadStatus.abstractPiece = true;
                updateProgress();

                // Cargar piezas individuales con manejo de errores mejorado
                window.Pieces = {};
                const pieceFiles = [
                    'Pawn.js', 'Knight.js', 'Bishop.js', 'Rook.js', 'Queen.js', 'King.js'
                ];

                let successCount = 0;
                const loadPromises = pieceFiles.map(async (file) => {
                    const pieceName = file.replace('.js', '');
                    try {
                        const pieceModule = await loadModule(`Objects/Pieces/${file}`, pieceName);
                        window.Pieces[pieceName] = pieceModule[pieceName] || pieceModule.default || pieceModule;
                        console.log(`‚úÖ ${pieceName} cargado`);
                        successCount++;
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è No se pudo cargar ${pieceName}, usando alternativa:`, error.message);
                        window.Pieces[pieceName] = createFallbackPiece(pieceName);
                        successCount++;
                    }
                });

                await Promise.allSettled(loadPromises);

                if (successCount > 0) {
                    loadStatus.pieces = true;
                    updateProgress();
                    console.log(`‚úÖ ${successCount}/${pieceFiles.length} piezas cargadas`);
                } else {
                    throw new Error('No se pudo cargar ninguna pieza');
                }

            } catch (error) {
                throw new Error(`Error configurando piezas: ${error.message}`);
            }
        }

        // --- CARGAR LIBRER√çAS DE CONTROL Y LOADER (Scripts Tradicionales - CORRECCI√ìN CLAVE FINAL) ---
        async function loadOptionalLibs() {
            updateLoadingText("Saltando librer√≠as opcionales problem√°ticas (Loaders/Controles)...");

            // *** CORRECCI√ìN CLAVE FINAL: Omitir TODAS las librer√≠as auxiliares (MTL/OBJ Loader, Controles, BVH)
            // para forzar el inicio de la escena 3D y confirmar si el bloqueo se resuelve. ***
            const optionalDeps = [];

            let loadedCount = 0;

            // Este bucle ahora est√° vac√≠o, evitando cualquier inyecci√≥n de script.
            for (const path of optionalDeps) {
                const success = await loadScript(path, path.split('/').pop());
                if (success) loadedCount++;
            }

            console.log(`‚úÖ ${loadedCount}/${optionalDeps.length} librer√≠as opcionales inyectadas. (Todas omitidas para forzar el inicio)`);

            loadStatus.optionalLibs = true;
            updateProgress();
        }

        // --- CARGAR ESCENA PRINCIPAL (M√≥dulo ES) ---
        async function loadScene() {
            try {
                updateLoadingText("Iniciando juego de ajedrez 3D...");

                // Cargar AllPieces si existe (M√≥dulo ES)
                try {
                    await loadModule('Objects/Pieces/AllPieces.js', 'AllPieces');
                } catch (e) {
                    console.warn('AllPieces.js no disponible, usando piezas individuales');
                }

                // Cargar Scene.js principal (M√≥dulo ES)
                const SceneModule = await loadModule('Scene.js', 'Scene', 3);

                // Encontrar el constructor de la escena
                const SceneConstructor = SceneModule.MyScene || SceneModule.Scene || SceneModule.default;

                if (typeof SceneConstructor === 'function') {
                    // Instancia la escena, que usa THREE.js para renderizar
                    const sceneInstance = new SceneConstructor("#chessCanvas");
                    loadStatus.scene = true;
                    updateProgress();
                    return sceneInstance;
                } else {
                    throw new Error('No se encontr√≥ un constructor v√°lido para Scene');
                }

            } catch (error) {
                throw new Error(`Error cargando escena: ${error.message}`);
            }
        }

        // --- FUNCI√ìN PRINCIPAL MEJORADA ---
        async function loadChessGame() {
            try {
                // Verificar WebGL
                if (!webglAvailable()) {
                    throw new Error('WebGL no est√° disponible en este navegador');
                }

                document.getElementById('debug-panel').style.display = 'block';
                updateDebugInfo();

                // Cargar en secuencia
                await loadCoreDependencies();
                await loadGeometrySystem();
                await loadPieces();
                await loadOptionalLibs(); // <--- Ahora vac√≠o

                const sceneInstance = await loadScene();

                // √âxito - ocultar pantalla de carga
                document.getElementById('loading').style.display = 'none';
                updateLoadingText("¬°Ajedrez 3D listo! üéâ");
                console.log('üéâ TMChess3D cargado exitosamente');

                return sceneInstance;

            } catch (error) {
                console.error('‚ùå Error cr√≠tico al cargar el juego:', error);
                showError(error);
            }
        }

        // --- Mostrar error mejorado (sin cambios) ---
        function showError(error) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';

            const errorDetails = document.getElementById('error-details');
            if (errorDetails) {
                errorDetails.innerHTML = `
                    <strong>Error:</strong> ${error.message}<br><br>
                    <strong>Estado de carga:</strong><br>
                    <pre>${JSON.stringify(loadStatus, null, 2)}</pre>
                `;
            }

            updateDebugInfo();
        }

        // --- Funciones de utilidad (sin cambios) ---
        function webglAvailable() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext &&
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
                return false;
            }
        }

        function retryLoad() {
            document.getElementById('error').style.display = 'none';
            document.getElementById('loading').style.display = 'flex';
            document.getElementById('progress-bar-inner').style.width = '0%';
            loadedModules = 0;
            Object.keys(loadStatus).forEach(key => loadStatus[key] = false);
            loadChessGame();
        }

        function toggleDebug() {
            const dp = document.getElementById('debug-panel');
            dp.style.display = dp.style.display === 'block' ? 'none' : 'block';
            updateDebugInfo();
        }

        // Iniciar carga cuando el DOM est√© listo
        document.addEventListener('DOMContentLoaded', loadChessGame);
    </script>
</body>
</html>
